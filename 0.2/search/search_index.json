{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open Vault: Deploy \u00b6 About \u00b6 Deployment documentation for the Open Vault project Links \u00b6 Site: ovfrontend.k8s.wgbhdigital.org Documentation: wgbh-mla.github.io/ov-deploy Github: github.com/WGBH-MLA/ov-deploy Credits \u00b6 Developed by the Media Library and Archives at WGBH Boston","title":"Home"},{"location":"#open-vault-deploy","text":"","title":"Open Vault: Deploy"},{"location":"#about","text":"Deployment documentation for the Open Vault project","title":"About"},{"location":"#links","text":"Site: ovfrontend.k8s.wgbhdigital.org Documentation: wgbh-mla.github.io/ov-deploy Github: github.com/WGBH-MLA/ov-deploy","title":"Links"},{"location":"#credits","text":"Developed by the Media Library and Archives at WGBH Boston","title":"Credits"},{"location":"deploy/","text":"Deployment \u00b6 General \u00b6 Deployments are run in Kubernetes on AWS. The workloads consist of pods (Docker containers) which run prebuilt images from Dockerhub. These images are built from the Dockerfile s of the ov-frontend and ov-wag repositories, and from the Dockerfile in the ov-nginx and ov-jumpbox subdirectories. Setup If you haven't set up a production environment, follow the steps in Setup first. Deployment Process \u00b6 Generally speaking, the deployment process consists of the following tasks: Checkout the desired versions of the image(s) to be built. Build Docker images from the Dockerfile s for each microservice. Push the Docker images to Dockerhub. Update the workloads in Kubernetes to use the updated Docker images. Scenario #1: Redeploy an ov_deploy commit \u00b6 These steps assume some ov_deploy commit should be pushed to some deployment environment, either production or demo . Starting from a known ov_deploy commit or branch: git checkout [commit or branch] git submodule update Scenario #2: Custom code \u00b6 In ov-wag and ov-frontend , checkout (or manually edit) the code in each repository. 1. Build images \u00b6 Build all images: ./ov build Build single image: ./ov build [image name] Note: Other custom commands can be passed into the 2. Push to docker hub \u00b6 (tag the image?) docker push [tag name] 3. Redeploy pods \u00b6 Redeploy the pod(s) Rancher kubectl ./deploy \u00b6 The ./deploy helper script is designed to automate the process of deploying known versions of parts or the whole stack. For any given pod, it will: Build the docker images Push the images to docker hub Set the version tag of each deployed image Usage \u00b6 The script can be called with several arguments: Setup kubectl context -c context TODO: kubectl context Describe setup for kubectl context Set pod(s) version as cli args Backend: -b VERSION Frontend: -f VERSION Proxy: -p VERSION Run command Verify in console logs that job has completed successfully, or returned an error. Example \u00b6 Deploy v0.1.0 of backend and frontend ./deploy -c openvault -b v0.1.0 -f v0.1.0","title":"Deploy"},{"location":"deploy/#deployment","text":"","title":"Deployment"},{"location":"deploy/#general","text":"Deployments are run in Kubernetes on AWS. The workloads consist of pods (Docker containers) which run prebuilt images from Dockerhub. These images are built from the Dockerfile s of the ov-frontend and ov-wag repositories, and from the Dockerfile in the ov-nginx and ov-jumpbox subdirectories. Setup If you haven't set up a production environment, follow the steps in Setup first.","title":"General"},{"location":"deploy/#deployment-process","text":"Generally speaking, the deployment process consists of the following tasks: Checkout the desired versions of the image(s) to be built. Build Docker images from the Dockerfile s for each microservice. Push the Docker images to Dockerhub. Update the workloads in Kubernetes to use the updated Docker images.","title":"Deployment Process"},{"location":"deploy/#scenario-1-redeploy-an-ov_deploy-commit","text":"These steps assume some ov_deploy commit should be pushed to some deployment environment, either production or demo . Starting from a known ov_deploy commit or branch: git checkout [commit or branch] git submodule update","title":"Scenario #1: Redeploy an ov_deploy commit"},{"location":"deploy/#scenario-2-custom-code","text":"In ov-wag and ov-frontend , checkout (or manually edit) the code in each repository.","title":"Scenario #2: Custom code"},{"location":"deploy/#1-build-images","text":"Build all images: ./ov build Build single image: ./ov build [image name] Note: Other custom commands can be passed into the","title":"1. Build images"},{"location":"deploy/#2-push-to-docker-hub","text":"(tag the image?) docker push [tag name]","title":"2. Push to docker hub"},{"location":"deploy/#3-redeploy-pods","text":"Redeploy the pod(s) Rancher kubectl","title":"3. Redeploy pods"},{"location":"deploy/#deploy","text":"The ./deploy helper script is designed to automate the process of deploying known versions of parts or the whole stack. For any given pod, it will: Build the docker images Push the images to docker hub Set the version tag of each deployed image","title":"./deploy"},{"location":"deploy/#usage","text":"The script can be called with several arguments: Setup kubectl context -c context TODO: kubectl context Describe setup for kubectl context Set pod(s) version as cli args Backend: -b VERSION Frontend: -f VERSION Proxy: -p VERSION Run command Verify in console logs that job has completed successfully, or returned an error.","title":"Usage"},{"location":"deploy/#example","text":"Deploy v0.1.0 of backend and frontend ./deploy -c openvault -b v0.1.0 -f v0.1.0","title":"Example"},{"location":"dev/","text":"Development \u00b6 This page describes how to run the development environment on a machine with docker compose . Requirements docker docker compose Running the services outside of docker is possible, but not supported in this context. ./ov \u00b6 The ov file is the primary Open Vault command line script. This contains a number of pre-built commands to do basic operations Usage \u00b6 ./ov COMMAND [args] ./ov --help COMMANDS: b | build build the docker images backup | dump create a backup of the database c | cmd run a compose command d | dev start a development server deploy run a ./deploy command i | init run initialization script h | help prints this help text m | manage run a wagtail manage.py command restore | load restore a database backup s | shell run a django shell command with the app context Commands \u00b6 b | build \u00b6 Build the docker images locally. build a single image Additional docker arguments can be passed to this command. For example, to build only a single image: Build frontend ./ov b front backup | dump \u00b6 Create a database dump file with the timestamp as the filename. c | cmd \u00b6 Run a docker compose command with the base config files in place. d | dev \u00b6 Run Development Environment Run the development environment, with docker compose , and follow container logs. Compose arguments Additional compose arguments can be passed. For example, to rebuild the containers before running: ./ov d --build deploy \u00b6 Shortcut for ./deploy [command] . See Deploy for detailed usage. docs \u00b6 Build and run the documentation server, with live change reloading. i | init \u00b6 Initialize a development environment. See Setup for detailed instructions. m | manage \u00b6 Run a manage.py command in the docker context. restore \u00b6 Restore the database with a backup. restore db ./ov restore db_backup.sql s | shell \u00b6 Enter into a python django shell interpreter, with the application context loaded. Examples \u00b6 The following are some useful examples of development commands that might be run: Migrate database \u00b6 Generating the migration files can be accomplished with: ./ov m makemigrations To Run the database migrations: ./ov m migrate Show the logs \u00b6 Show the docker compose logs ./ov c logs Show logs for just the frontend ./ov c logs ov-frontend","title":"Develop"},{"location":"dev/#development","text":"This page describes how to run the development environment on a machine with docker compose . Requirements docker docker compose Running the services outside of docker is possible, but not supported in this context.","title":"Development"},{"location":"dev/#ov","text":"The ov file is the primary Open Vault command line script. This contains a number of pre-built commands to do basic operations","title":"./ov"},{"location":"dev/#usage","text":"./ov COMMAND [args] ./ov --help COMMANDS: b | build build the docker images backup | dump create a backup of the database c | cmd run a compose command d | dev start a development server deploy run a ./deploy command i | init run initialization script h | help prints this help text m | manage run a wagtail manage.py command restore | load restore a database backup s | shell run a django shell command with the app context","title":"Usage"},{"location":"dev/#commands","text":"","title":"Commands"},{"location":"dev/#b-build","text":"Build the docker images locally. build a single image Additional docker arguments can be passed to this command. For example, to build only a single image: Build frontend ./ov b front","title":"b | build"},{"location":"dev/#backup-dump","text":"Create a database dump file with the timestamp as the filename.","title":"backup | dump"},{"location":"dev/#c-cmd","text":"Run a docker compose command with the base config files in place.","title":"c | cmd"},{"location":"dev/#d-dev","text":"Run Development Environment Run the development environment, with docker compose , and follow container logs. Compose arguments Additional compose arguments can be passed. For example, to rebuild the containers before running: ./ov d --build","title":"d | dev"},{"location":"dev/#deploy","text":"Shortcut for ./deploy [command] . See Deploy for detailed usage.","title":"deploy"},{"location":"dev/#docs","text":"Build and run the documentation server, with live change reloading.","title":"docs"},{"location":"dev/#i-init","text":"Initialize a development environment. See Setup for detailed instructions.","title":"i | init"},{"location":"dev/#m-manage","text":"Run a manage.py command in the docker context.","title":"m | manage"},{"location":"dev/#restore","text":"Restore the database with a backup. restore db ./ov restore db_backup.sql","title":"restore"},{"location":"dev/#s-shell","text":"Enter into a python django shell interpreter, with the application context loaded.","title":"s | shell"},{"location":"dev/#examples","text":"The following are some useful examples of development commands that might be run:","title":"Examples"},{"location":"dev/#migrate-database","text":"Generating the migration files can be accomplished with: ./ov m makemigrations To Run the database migrations: ./ov m migrate","title":"Migrate database"},{"location":"dev/#show-the-logs","text":"Show the docker compose logs ./ov c logs Show logs for just the frontend ./ov c logs ov-frontend","title":"Show the logs"},{"location":"manual/","text":"Manual deployment \u00b6 In the event that an automated deployment fails you can do a step-by-step deployment to help debug problems. Requirements \u00b6 On your local machine, you will need: docker kubectl Authorization In addition to the software requirements, in order to manage the deployment stack, you will need: Authorization to push docker images to wgbhmla Dockerhub account. Access to the GBH VPN TODO: Verify dependencies Add doc on how to verify that you have all these dependencies, and if not, how to get them._ OV_*_VERSION The versions of ov-wag and ov-frontend repositories will be used in several of the following commands, so the following commands are documented with the $OV_WAG_VERSION and $OV_FRONTEND_VERSION variables. You can set these in your session by using export Export OV_*_VERSION export OV_WAG_VERSION =[ tag | branch | commit ] export OV_FRONTEND_VERSION =[ tag | branch | commit ] After setting up the repository : Steps \u00b6 Build images \u00b6 Set the ov-wag submodule to the tag, branch, or commit that you want to deploy. Checkout backend cd ov-wag git checkout $OV_WAG_VERSION cd .. Set the ov-frontend submodule to the tag, branch, or commit that you want to deploy. Checkout frontend cd ov-frontend git checkout $OV_FRONTEND_VERSION cd .. Build Docker images. Build docker images docker build -t wgbhmla/ov-wag: $OV_WAG_VERSION --target production ./ov-wag docker build -t wgbhmla/ov-frontend: $OV_FRONTEND_VERSION --target production ./ov-frontend TODO: change build from production to deployment ? This would require a change to Dockerfile in ov-wag repo, but would be less confusing since the image may end up in either Production or Demo environments. Push images \u00b6 Login to docker hub docker login docker login --username wgbhmla Push newly built images to Docker Hub push images docker push wgbhmla/ov-wag: $OV_WAG_VERSION docker push wgbhmla/ov-frontend: $OV_FRONTEND_VERSION Passwords The password for Docker Hub user wgbhmla is in passwordstate . Update Kubernetes workloads \u00b6 There several ways of updating the Kubernetes workflow: kubectl commands Rancher web interface ./deploy The ./deploy script is designed to execute the necessary kubectl commands from an authorized device. It See usage details in Deploy Using kubectl \u00b6 Set the context Set the kubectl context kubectl config use-context openvault Set the app image deployment tag set backend version to v0.2.0 kubectl set image deployment.apps/ov-wag ov-wag = wgbhmla/ov-wag:v0.2.0 Using the Rancher web interface \u00b6 TODO: needs more affirming feedback Go through steps to ensure consistency Login Login to VPN Login to Rancher (\"Log in with Azure ID\") Go to MLA project Select the Workloads tab, if it is not already selected. Other tabs are: Load Balancing , Service Discovery , and Volumes . Locate \"Namespace: openvault\" Click on the row identifying the ov-wag workload Edit the Docker Image value to the desired image:tag combination Click Save TODO: add where to check logs, get feedback on success/fail TODO: image pull policy add details about \"image pull policy\" and make sure it's set correctly -- i think to 'always pull' or something Example workflow \u00b6 git clone git@github.com:WGBH-MLA/ov_deploy.git cd ov_deploy git ch -b test-new-versions-of-front-and-back-ends ./ov deploy \\ # required parameters \\ --namespace=openvault-demo \\ --ov-wag-version=v1.1.0 \\ --ov-frontend-version=v2.2.0 \\ # optional params, values shown are defaults --ov-wag-env=./ov-wag/env.yml \\ --ov-wag-secrets=./ov-wag/secrets.yml \\ --ov-frontend-env=./ov-frontend/env.yml \\ TODO: clean manual script qa testing ensues it works hooray! Now, do we branch/pr/merge manual deploy for now until continuous-deploy? Do we first deploy to prod to ensure it's working so that we can do a quick rollback without involving continuous deployment in case of error? Or, do we not check in anything? Deploy to prod, check it out, and we're done.","title":"Manual"},{"location":"manual/#manual-deployment","text":"In the event that an automated deployment fails you can do a step-by-step deployment to help debug problems.","title":"Manual deployment"},{"location":"manual/#requirements","text":"On your local machine, you will need: docker kubectl Authorization In addition to the software requirements, in order to manage the deployment stack, you will need: Authorization to push docker images to wgbhmla Dockerhub account. Access to the GBH VPN TODO: Verify dependencies Add doc on how to verify that you have all these dependencies, and if not, how to get them._ OV_*_VERSION The versions of ov-wag and ov-frontend repositories will be used in several of the following commands, so the following commands are documented with the $OV_WAG_VERSION and $OV_FRONTEND_VERSION variables. You can set these in your session by using export Export OV_*_VERSION export OV_WAG_VERSION =[ tag | branch | commit ] export OV_FRONTEND_VERSION =[ tag | branch | commit ] After setting up the repository :","title":"Requirements"},{"location":"manual/#steps","text":"","title":"Steps"},{"location":"manual/#build-images","text":"Set the ov-wag submodule to the tag, branch, or commit that you want to deploy. Checkout backend cd ov-wag git checkout $OV_WAG_VERSION cd .. Set the ov-frontend submodule to the tag, branch, or commit that you want to deploy. Checkout frontend cd ov-frontend git checkout $OV_FRONTEND_VERSION cd .. Build Docker images. Build docker images docker build -t wgbhmla/ov-wag: $OV_WAG_VERSION --target production ./ov-wag docker build -t wgbhmla/ov-frontend: $OV_FRONTEND_VERSION --target production ./ov-frontend TODO: change build from production to deployment ? This would require a change to Dockerfile in ov-wag repo, but would be less confusing since the image may end up in either Production or Demo environments.","title":"Build images"},{"location":"manual/#push-images","text":"Login to docker hub docker login docker login --username wgbhmla Push newly built images to Docker Hub push images docker push wgbhmla/ov-wag: $OV_WAG_VERSION docker push wgbhmla/ov-frontend: $OV_FRONTEND_VERSION Passwords The password for Docker Hub user wgbhmla is in passwordstate .","title":"Push images"},{"location":"manual/#update-kubernetes-workloads","text":"There several ways of updating the Kubernetes workflow: kubectl commands Rancher web interface ./deploy The ./deploy script is designed to execute the necessary kubectl commands from an authorized device. It See usage details in Deploy","title":"Update Kubernetes workloads"},{"location":"manual/#using-kubectl","text":"Set the context Set the kubectl context kubectl config use-context openvault Set the app image deployment tag set backend version to v0.2.0 kubectl set image deployment.apps/ov-wag ov-wag = wgbhmla/ov-wag:v0.2.0","title":"Using kubectl"},{"location":"manual/#using-the-rancher-web-interface","text":"TODO: needs more affirming feedback Go through steps to ensure consistency Login Login to VPN Login to Rancher (\"Log in with Azure ID\") Go to MLA project Select the Workloads tab, if it is not already selected. Other tabs are: Load Balancing , Service Discovery , and Volumes . Locate \"Namespace: openvault\" Click on the row identifying the ov-wag workload Edit the Docker Image value to the desired image:tag combination Click Save TODO: add where to check logs, get feedback on success/fail TODO: image pull policy add details about \"image pull policy\" and make sure it's set correctly -- i think to 'always pull' or something","title":"Using the Rancher web interface"},{"location":"manual/#example-workflow","text":"git clone git@github.com:WGBH-MLA/ov_deploy.git cd ov_deploy git ch -b test-new-versions-of-front-and-back-ends ./ov deploy \\ # required parameters \\ --namespace=openvault-demo \\ --ov-wag-version=v1.1.0 \\ --ov-frontend-version=v2.2.0 \\ # optional params, values shown are defaults --ov-wag-env=./ov-wag/env.yml \\ --ov-wag-secrets=./ov-wag/secrets.yml \\ --ov-frontend-env=./ov-frontend/env.yml \\ TODO: clean manual script qa testing ensues it works hooray! Now, do we branch/pr/merge manual deploy for now until continuous-deploy? Do we first deploy to prod to ensure it's working so that we can do a quick rollback without involving continuous deployment in case of error? Or, do we not check in anything? Deploy to prod, check it out, and we're done.","title":"Example workflow"},{"location":"setup/","text":"Setup \u00b6 Development \u00b6 The following steps describe the setup process for local development. For production setup, see Production 0. Checkout code \u00b6 Clone the source code from github, including submodules: git clone --recurse-submodules https://github.com/WGBH-MLA/ov-deploy.git Change into the new ov-deploy directory cd ov-deploy Initialize and update submodules If the repository was cloned without the submodules, they will need to be initialized first. git submodule init git submodule update Checkout code If running a version other than the main branch, you will need to checkout the code first, and update the git submodules. Usually this will be a tag or a branch. For example, if checking out v0.2.0 : git checkout v0.2.0 git submodule update 1. Create the database secrets file \u00b6 In ov-wag , create a file called .db with the following contents: ov-wag/.db POSTGRES_PASSWORD = \"YOUR POSTGRES PASSWORD HERE\" Generating a password This command will generate a new password config file and save it to ov-wag/.db WARNING: This will overwrite any existing password stored in the .db file! \u00b6 Run this command from the top level ov-deploy/ directory. echo \"POSTGRES_PASSWORD= $( openssl rand -base64 24 ) \" > ov-wag/.db 2. Create the backend secrets file \u00b6 In ov-wag , create a file called .env with the following contents: ov-wag/.env OV_DB_ENGINE = django.db.backends.postgresql OV_DB_PORT = 5432 OV_DB_NAME = postgres OV_DB_USER = postgres OV_DB_PASSWORD = \"YOUR POSTGRES PASSWORD HERE\" 3. Run initialization script \u00b6 ./ov init ./ov init script This is the equivalent of running: ./ov build # (1) ./ov c run -it front npm install # (2) build docker files install npm requirements Production \u00b6 If deploying for the first time, Kubernetes must be configured to receive deployments. If this has already been done, you can skip this section. Login Login to VPN Login to Rancher (\"Log in with Azure ID\") Go to MLA project Create namespace \u00b6 TODO: elaborate Create workloads \u00b6 For each workload: From the Workloads tab of the project, Click Deploy Enter the name of the service Service name If using the automatic deploy script, the name of the service must exactly match the name of the docker hub image Set the Docker image to: [DOCKERHUB ACCOUNT NAME]/[DOCKER IMAGE NAME]:[TAG] For example: wgbhmla/ov-wag:latest Set environment variables Create a new config map with the necessary environment variables. Resources > Config > Add Config Map ov-wag-config OV_DB_ENGINE = django.db.backends.postgresql OV_DB_PORT = 5432 OV_DB_NAME = postgres OV_DB_USER = postgres Click Add From Source and set type: Config Map Select the name of the config map Enter secrets Add a new secret with any secrets that need to be available. Click Add From Source and set type: Secret ov-wag-secret OV_DB_PASSWORD = p@ssW0rd! TODO: Enumerate kube steps Enumerate the minimum steps required to get Kubernetes setup up in Rancher to handle deployments. Workloads \u00b6 The following services are needed to run the stack: db \u00b6 image: postgres:14.2-alpine secrets: db secrets POSTGRES_PASSWORD = p@ssW0rd! ov-wag (backend) \u00b6 image: wgbhmla/ov-wag config: ov-wag environment OV_DB_ENGINE = django.db.backends.postgresql OV_DB_PORT = 5432 OV_DB_NAME = postgres OV_DB_USER = postgres secrets: ov-wag.secrets OV_DB_PASSWORD = p@ssW0rd! ov-frontend \u00b6 image: wgbhmla/ov-frontend config: ov-frontend environment OV_API_URL = ov-wag ov-nginx \u00b6 image: wgbhmla/ov-nginx preconfigured with nginx.conf proxy pass to http://ov-frontend:3000 endpoints: 80/http Load Balancing: hostname: [public url] jumpbox \u00b6 image: wgbhmla/jumpbox","title":"Setup"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#development","text":"The following steps describe the setup process for local development. For production setup, see Production","title":"Development"},{"location":"setup/#0-checkout-code","text":"Clone the source code from github, including submodules: git clone --recurse-submodules https://github.com/WGBH-MLA/ov-deploy.git Change into the new ov-deploy directory cd ov-deploy Initialize and update submodules If the repository was cloned without the submodules, they will need to be initialized first. git submodule init git submodule update Checkout code If running a version other than the main branch, you will need to checkout the code first, and update the git submodules. Usually this will be a tag or a branch. For example, if checking out v0.2.0 : git checkout v0.2.0 git submodule update","title":"0. Checkout code"},{"location":"setup/#1-create-the-database-secrets-file","text":"In ov-wag , create a file called .db with the following contents: ov-wag/.db POSTGRES_PASSWORD = \"YOUR POSTGRES PASSWORD HERE\" Generating a password This command will generate a new password config file and save it to ov-wag/.db","title":"1. Create the database secrets file"},{"location":"setup/#2-create-the-backend-secrets-file","text":"In ov-wag , create a file called .env with the following contents: ov-wag/.env OV_DB_ENGINE = django.db.backends.postgresql OV_DB_PORT = 5432 OV_DB_NAME = postgres OV_DB_USER = postgres OV_DB_PASSWORD = \"YOUR POSTGRES PASSWORD HERE\"","title":"2. Create the backend secrets file"},{"location":"setup/#3-run-initialization-script","text":"./ov init ./ov init script This is the equivalent of running: ./ov build # (1) ./ov c run -it front npm install # (2) build docker files install npm requirements","title":"3. Run initialization script"},{"location":"setup/#production","text":"If deploying for the first time, Kubernetes must be configured to receive deployments. If this has already been done, you can skip this section. Login Login to VPN Login to Rancher (\"Log in with Azure ID\") Go to MLA project","title":"Production"},{"location":"setup/#create-namespace","text":"TODO: elaborate","title":"Create namespace"},{"location":"setup/#create-workloads","text":"For each workload: From the Workloads tab of the project, Click Deploy Enter the name of the service Service name If using the automatic deploy script, the name of the service must exactly match the name of the docker hub image Set the Docker image to: [DOCKERHUB ACCOUNT NAME]/[DOCKER IMAGE NAME]:[TAG] For example: wgbhmla/ov-wag:latest Set environment variables Create a new config map with the necessary environment variables. Resources > Config > Add Config Map ov-wag-config OV_DB_ENGINE = django.db.backends.postgresql OV_DB_PORT = 5432 OV_DB_NAME = postgres OV_DB_USER = postgres Click Add From Source and set type: Config Map Select the name of the config map Enter secrets Add a new secret with any secrets that need to be available. Click Add From Source and set type: Secret ov-wag-secret OV_DB_PASSWORD = p@ssW0rd! TODO: Enumerate kube steps Enumerate the minimum steps required to get Kubernetes setup up in Rancher to handle deployments.","title":"Create workloads"},{"location":"setup/#workloads","text":"The following services are needed to run the stack:","title":"Workloads"},{"location":"setup/#db","text":"image: postgres:14.2-alpine secrets: db secrets POSTGRES_PASSWORD = p@ssW0rd!","title":"db"},{"location":"setup/#ov-wag-backend","text":"image: wgbhmla/ov-wag config: ov-wag environment OV_DB_ENGINE = django.db.backends.postgresql OV_DB_PORT = 5432 OV_DB_NAME = postgres OV_DB_USER = postgres secrets: ov-wag.secrets OV_DB_PASSWORD = p@ssW0rd!","title":"ov-wag (backend)"},{"location":"setup/#ov-frontend","text":"image: wgbhmla/ov-frontend config: ov-frontend environment OV_API_URL = ov-wag","title":"ov-frontend"},{"location":"setup/#ov-nginx","text":"image: wgbhmla/ov-nginx preconfigured with nginx.conf proxy pass to http://ov-frontend:3000 endpoints: 80/http Load Balancing: hostname: [public url]","title":"ov-nginx"},{"location":"setup/#jumpbox","text":"image: wgbhmla/jumpbox","title":"jumpbox"},{"location":"stack/","text":"About the Stack \u00b6 Open Vault is deployed as a number of separate services, built into docker images. Development is done with docker compose Deployment is orchestrated through kubernetes , using Rancher . Microservices vs macro application While it is possible to run all services combined on a single physical or virtual instance, it is strongly recommended to run as a series of micro-services, which can be versioned and scaled independently. All documentation here will describe deployment through docker and kubernetes . Concepts \u00b6 The following are some definitions for some of the terms used below: Production \u00b6 The fully deployed stack, publicly available to all clients Demo / Staging \u00b6 A separate production stack, used to test changes and maintain a live working backup. This will be available on a different domain than the production stack Image \u00b6 A docker container containing all the code needed to run a single service. Pod \u00b6 A single instance of a running docker image. Namespace \u00b6 The name of the Kubernetes context. Valid namespaces Currently, this must be one of: openvault ov-demo Services \u00b6 These are the pre-built docker images to deploy various microservices: ov-frontend \u00b6 Javascript frontend, built with remix Source: github.com/WGBH-MLA/ov-frontend/ Docker: wgbhmla/ov-frontend ov-wag \u00b6 Python backend and API, built with wagtail Source: github.com/WGBH-MLA/ov-wag Docker: wgbhmla/ov-wag db \u00b6 Database. Built with PostgreSQL image: postgres:14.2-alpine ov-nginx \u00b6 Proxy image, using nginx image: ov-nginx:v0.1.0 jumpbox \u00b6 Optional utility kit, based on ubuntu with command line helpers such as: curl postgres python Call sequence \u00b6 The following diagram describes the call sequence for incoming requests: sequenceDiagram Client ->> Proxy: requests page Proxy -->> Frontend: nginx proxies request Frontend ->> Backend: fetches latest data from API Backend ->> DB: polls the database DB ->> Backend: return database results Backend ->> Frontend: return API results Frontend -->> Proxy: build page with latest results Proxy ->> Client: return page","title":"Stack"},{"location":"stack/#about-the-stack","text":"Open Vault is deployed as a number of separate services, built into docker images. Development is done with docker compose Deployment is orchestrated through kubernetes , using Rancher . Microservices vs macro application While it is possible to run all services combined on a single physical or virtual instance, it is strongly recommended to run as a series of micro-services, which can be versioned and scaled independently. All documentation here will describe deployment through docker and kubernetes .","title":"About the Stack"},{"location":"stack/#concepts","text":"The following are some definitions for some of the terms used below:","title":"Concepts"},{"location":"stack/#production","text":"The fully deployed stack, publicly available to all clients","title":"Production"},{"location":"stack/#demo-staging","text":"A separate production stack, used to test changes and maintain a live working backup. This will be available on a different domain than the production stack","title":"Demo / Staging"},{"location":"stack/#image","text":"A docker container containing all the code needed to run a single service.","title":"Image"},{"location":"stack/#pod","text":"A single instance of a running docker image.","title":"Pod"},{"location":"stack/#namespace","text":"The name of the Kubernetes context. Valid namespaces Currently, this must be one of: openvault ov-demo","title":"Namespace"},{"location":"stack/#services","text":"These are the pre-built docker images to deploy various microservices:","title":"Services"},{"location":"stack/#ov-frontend","text":"Javascript frontend, built with remix Source: github.com/WGBH-MLA/ov-frontend/ Docker: wgbhmla/ov-frontend","title":"ov-frontend"},{"location":"stack/#ov-wag","text":"Python backend and API, built with wagtail Source: github.com/WGBH-MLA/ov-wag Docker: wgbhmla/ov-wag","title":"ov-wag"},{"location":"stack/#db","text":"Database. Built with PostgreSQL image: postgres:14.2-alpine","title":"db"},{"location":"stack/#ov-nginx","text":"Proxy image, using nginx image: ov-nginx:v0.1.0","title":"ov-nginx"},{"location":"stack/#jumpbox","text":"Optional utility kit, based on ubuntu with command line helpers such as: curl postgres python","title":"jumpbox"},{"location":"stack/#call-sequence","text":"The following diagram describes the call sequence for incoming requests: sequenceDiagram Client ->> Proxy: requests page Proxy -->> Frontend: nginx proxies request Frontend ->> Backend: fetches latest data from API Backend ->> DB: polls the database DB ->> Backend: return database results Backend ->> Frontend: return API results Frontend -->> Proxy: build page with latest results Proxy ->> Client: return page","title":"Call sequence"}]}